<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debayan Mukherjee | Creative Technologist</title>
    <style>
        :root {
            --metal-grey: #303030;
            --light-grey: #e0e0e0;
            --accent-red: #ff3333;
            --silver: #c0c0c0;
            --black: #000000;
            --white: #ffffff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }
        
        body {
            background-color: black;
            color: white;
            overflow: hidden;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: -1;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 2rem;
            z-index: 10;
            display: flex;
            justify-content: flex-end;
            align-items: center;
        }
        
        .nav-links {
            display: flex;
            gap: 1.5rem;
        }
        
        .nav-link {
            color: var(--white);
            text-decoration: none;
            font-size: 0.8rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: color 0.3s ease;
        }
        
        .nav-link:hover {
            color: var(--accent-red);
        }
        
        /* Landing Content */
        .landing-content {
            position: absolute;
            top: 50%;
            left: 5%;
            transform: translate(0, -50%);
            text-align: left;
            z-index: 10;
            width: 80%;
            max-width: 1200px;
        }
        
        .name-title {
            font-size: 5rem;
            font-weight: 200;
            margin-bottom: 0.5rem;
            letter-spacing: 1px;
            text-transform: titlecase;
            position: relative;
            font-family: 'Syncopate', 'Orbitron', 'Rajdhani', sans-serif;
            line-height: 1;
            color: white;
            text-shadow: 0 0 25px rgba(255, 255, 255, 0.5);
            mix-blend-mode: difference;
        }
        
        .red-text {
            font-weight: 700;
            letter-spacing: 4px;
            position: relative;
            display: block;
            color: var(--accent-red);
            text-shadow: 0 0 20px rgba(255, 51, 51, 0.7);
            font-size: 4em;
            margin-top: 0.1em;
            margin-bottom: 0.3em;
        }
        
        .social-links {
            display: flex;
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .social-link {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            color: var(--light-grey);
            text-decoration: none;
            font-size: 1rem;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            opacity: 0.8;
        }
        
        .social-link:hover {
            color: var(--accent-red);
            opacity: 1;
        }
        
        .social-link svg {
            width: 20px;
            height: 20px;
            transition: all 0.3s ease;
            transform: translateY(-1px);
        }
        
        .social-link:hover svg {
            stroke: var(--accent-red);
            transform: translateY(-3px);
        }
        
        .social-link span {
            transition: all 0.3s ease;
        }
        
        .social-link:hover span {
            color: var(--accent-red);
            transform: translateY(-3px);
        }
        
        /* Add font imports */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Rajdhani:wght@300;400;500&family=Syncopate:wght@400;700&display=swap');
        
        /* Responsive styles */
        @media (max-width: 1024px) {
            .name-title {
                font-size: 4rem;
            }
            
            .landing-content {
                left: 10%;
                transform: translate(0, -50%);
            }
        }
        
        @media (max-width: 768px) {
            .name-title {
                font-size: 3rem;
                transform: perspective(1000px) rotateX(5deg) rotateY(-5deg);
            }
            
            .landing-content {
                left: 5%;
                width: 90%;
            }
            
            header {
                flex-direction: column;
                align-items: flex-end;
            }
            
            .nav-links {
                margin-top: 1rem;
                flex-wrap: wrap;
                justify-content: flex-end;
            }
        }
        
        @media (max-width: 480px) {
            .name-title {
                font-size: 2.5rem;
            }
            
            .landing-content {
                left: 5%;
                width: 90%;
            }
            
            .nav-links {
                gap: 1rem;
            }
            
            .download-btn {
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    
    <header>
        <div class="nav-links">
            <a href="pages/creative-design.html" class="nav-link">Creative Design</a>
            <a href="pages/visual-experience.html" class="nav-link">Visual Experience</a>
            <a href="pages/creative-tech.html" class="nav-link">Technology</a>
            <a href="pages/photography.html" class="nav-link">Photography</a>
            <a href="pages/about.html" class="nav-link">About</a>
        </div>
    </header>
    
    <div class="landing-content">
        <h1 class="name-title">Debayan</h1>
        <div class="red-text">Mukherjee</div>
        <div class="social-links">
            <a href="resume/Debayan_resume_2025.pdf" class="social-link" download>
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                <span>Bio</span>
            </a>
            <a href="https://www.linkedin.com/in/debayan-mukherjee-15954723/" class="social-link" target="_blank">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path>
                    <rect x="2" y="9" width="4" height="12"></rect>
                    <circle cx="4" cy="4" r="2"></circle>
                </svg>
                <span>LinkedIn</span>
            </a>
            <a href="https://github.com/debayanmkrj" class="social-link" target="_blank">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
                </svg>
                <span>GitHub</span>
            </a>
        </div>
    </div>
    
    <audio id="background-audio" autoplay loop>
        <source src="audio/landing_page.mp3" type="audio/mp3">
    </audio>
    
    <script>
        console.log("3D particle system initializing...");
        
        // Three.js variables
        let scene, camera, renderer, pointCloud;
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;
        let disintegrationFactor = 0;
        let rotationSpeed = 0.004;
        
        // Audio element
        let audioElement = document.getElementById('background-audio');
        let audioStarted = false;
        
        // Force audio to play on page load
        window.addEventListener('load', function() {
            audioElement.play().catch(function(e) {
                console.log("Audio couldn't autoplay on load, waiting for mouse movement");
            });
        });
        
        // Try to play on first mouse movement
        document.addEventListener('mousemove', function playAudioOnMove() {
            if (!audioStarted) {
                audioElement.play().then(function() {
                    audioStarted = true;
                    console.log("Audio started on mouse movement");
                }).catch(function(e) {
                    console.log("Audio still couldn't play on mouse movement");
                });
                
                // Remove the event listener after first attempt
                if (audioStarted) {
                    document.removeEventListener('mousemove', playAudioOnMove);
                }
            }
        });
        
        // Higher particle count for better detail
        const pointCount = 250000;
        
        // Arrays to store original and target positions for disintegration
        let originalPositions = [];
        let targetPositions = [];
        let originalColors = [];
        
        // Define color palette
        const colorPalette = {
            red: { r: 1.0, g: 0.2, b: 0.2 },         // Accent red
            metalGray: { r: 0.19, g: 0.19, b: 0.19 }, // Metal gray #303030
            white: { r: 0.88, g: 0.88, b: 0.88 },    // White/light gray
            black: { r: 0.05, g: 0.05, b: 0.05 }     // Black
        };
        
        // Initialize everything
        init();
        
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 550;
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true 
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Create a particle texture
            const particleTexture = createParticleTexture();
            
            // Create fashion tech point cloud
            createFashionTechPointCloud(particleTexture);
            
            // Add event listeners
            document.addEventListener('mousemove', onDocumentMouseMove);
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            animate();
        }
        
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            
            const context = canvas.getContext('2d');
            
            // Create radial gradient for soft-edged particle
            const gradient = context.createRadialGradient(
                16, 16, 0,    // inner circle
                16, 16, 16    // outer circle
            );
            
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');      // Center: full white
            gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');  // Mid: 80% white
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');      // Edge: transparent
            
            context.fillStyle = gradient;
            context.beginPath();
            context.arc(16, 16, 16, 0, Math.PI * 2);
            context.fill();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }
        
        function createFashionTechPointCloud(texture) {
            // Create a point cloud representing fashion tech
            console.log("Creating fashion tech point cloud");
            
            // Create geometry
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(pointCount * 3);
            const colors = new Float32Array(pointCount * 3);
            const sizes = new Float32Array(pointCount);
            
            // Use our color palette for fashion tech
            const fashionColors = [
                colorPalette.red,         // Red
                colorPalette.white,       // White
                colorPalette.metalGray,   // Metal gray
                colorPalette.black        // Black
            ];
            
            let index = 0;
            
            // Function to create a cluster of particles
            function createCluster(centerX, centerY, centerZ, width, height, depth, count, color, startIndex) {
                for (let i = 0; i < count && startIndex + i < pointCount; i++) {
                    const i3 = (startIndex + i) * 3;
                    
                    // Random position within the defined area
                    const x = centerX + (Math.random() - 0.5) * width;
                    const y = centerY + (Math.random() - 0.5) * height;
                    const z = centerZ + (Math.random() - 0.5) * depth;
                    
                    // Set position
                    positions[i3] = x;
                    positions[i3 + 1] = y;
                    positions[i3 + 2] = z;
                    
                    // Store original position
                    originalPositions.push({ x, y, z });
                    
                    // Create target position for disintegration
                    const distance = 800 + Math.random() * 1000;
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.random() * Math.PI;
                    
                    targetPositions.push({
                        x: distance * Math.sin(theta) * Math.cos(phi),
                        y: distance * Math.sin(theta) * Math.sin(phi),
                        z: distance * Math.cos(theta)
                    });
                    
                    // Set color
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                    
                    // Store original color
                    originalColors.push({
                        r: color.r,
                        g: color.g,
                        b: color.b
                    });
                    
                    // Set size
                    sizes[startIndex + i] = 2 + Math.random() * 3;
                }
                
                return startIndex + count;
            }
            
            // Create a dress/fashion silhouette (red)
            index = createCluster(0, 0, 0, 150, 350, 50, 20000, fashionColors[0], index);
            
            // Create a flowing fabric effect (white)
            index = createCluster(-100, -150, 30, 300, 100, 80, 15000, fashionColors[1], index);
            
            // Create tech elements (metal gray)
            for (let x = -200; x <= 200; x += 20) {
                for (let y = -200; y <= 200; y += 20) {
                    if (index < pointCount - 100) {
                        // Create a small cluster at each grid point
                        index = createCluster(x, y, 50, 5, 5, 5, 100, fashionColors[2], index);
                    }
                }
            }
            
            // Create a spiral pattern (mix of colors)
            const spiralPoints = 20000;
            
            for (let i = 0; i < spiralPoints && index < pointCount; i++) {
                const i3 = index * 3;
                
                const angle = 0.1 * i;
                const radius = 2 * angle;
                
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                const z = angle * 0.5;
                
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
                
                originalPositions.push({ x, y, z });
                
                // Create target position for disintegration
                const distance = 800 + Math.random() * 1000;
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                
                targetPositions.push({
                    x: distance * Math.sin(theta) * Math.cos(phi),
                    y: distance * Math.sin(theta) * Math.sin(phi),
                    z: distance * Math.cos(theta)
                });
                
                // Choose a color based on position in spiral
                const colorIndex = Math.floor(i / 1000) % fashionColors.length;
                const spiralColor = fashionColors[colorIndex];
                
                colors[i3] = spiralColor.r;
                colors[i3 + 1] = spiralColor.g;
                colors[i3 + 2] = spiralColor.b;
                
                // Store original color
                originalColors.push({
                    r: spiralColor.r,
                    g: spiralColor.g,
                    b: spiralColor.b
                });
                
                sizes[index] = 1.5 + Math.random() * 2;
                
                index++;
            }
            
            // Fill remaining with scattered particles
            while (index < pointCount) {
                const i3 = index * 3;
                
                // Random position
                const distance = 100 + Math.random() * 300;
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                
                const x = distance * Math.sin(theta) * Math.cos(phi);
                const y = distance * Math.sin(theta) * Math.sin(phi);
                const z = distance * Math.cos(phi);
                
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
                
                originalPositions.push({ x, y, z });
                
                // Target position for disintegration
                const targetDistance = 1200 + Math.random() * 1000;
                const targetPhi = Math.random() * Math.PI * 2;
                const targetTheta = Math.random() * Math.PI;
                
                targetPositions.push({
                    x: targetDistance * Math.sin(targetTheta) * Math.cos(targetPhi),
                    y: targetDistance * Math.sin(targetTheta) * Math.sin(targetPhi),
                    z: targetDistance * Math.cos(targetPhi)
                });
                
                // Random color
                const color = fashionColors[Math.floor(Math.random() * fashionColors.length)];
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
                
                // Store original color
                originalColors.push({
                    r: color.r,
                    g: color.g,
                    b: color.b
                });
                
                // Small size
                sizes[index] = 1 + Math.random();
                
                index++;
            }
            
            // Create attributes
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Create material
            const material = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                map: texture,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            // Create point cloud
            pointCloud = new THREE.Points(geometry, material);
            
            // Add to scene
            scene.add(pointCloud);
        }
        
        function onDocumentMouseMove(event) {
            // Try to start audio on mouse movement if not already started
            if (audioElement && !audioStarted) {
                audioElement.play().then(function() {
                    audioStarted = true;
                    console.log("Audio started on mouse movement");
                }).catch(function(e) {
                    console.log("Audio still couldn't play on mouse movement");
                });
            }
            
            // Calculate mouse position normalized across the whole screen width
            const normalizedX = event.clientX / window.innerWidth;
            
            // Set disintegration factor directly from mouse position
            disintegrationFactor = normalizedX;
            
            // Store mouse position for camera effects
            mouseX = (event.clientX - windowHalfX);
            mouseY = (event.clientY - windowHalfY);
            
            // Update particles
            updateParticles();
            
            // Update audio volume based on mouse position
            if (audioElement && audioStarted) {
                // When particles are more disintegrated (right side), volume is lower
                // When particles are more cohesive (left side), volume is higher
                audioElement.volume = 1.0 - (normalizedX * 0.7); // Volume range from 1.0 to 0.3
            }
        }
        
        function updateParticles() {
            if (!pointCloud) return;
            
            const positions = pointCloud.geometry.attributes.position.array;
            const colors = pointCloud.geometry.attributes.color.array;
            
            // Update each particle
            for (let i = 0; i < originalPositions.length; i++) {
                const i3 = i * 3;
                
                // Update position based on disintegration factor
                const orig = originalPositions[i];
                const target = targetPositions[i];
                
                positions[i3] = orig.x * (1 - disintegrationFactor) + target.x * disintegrationFactor;
                positions[i3 + 1] = orig.y * (1 - disintegrationFactor) + target.y * disintegrationFactor;
                positions[i3 + 2] = orig.z * (1 - disintegrationFactor) + target.z * disintegrationFactor;
                
                // Color transition logic
                const origColor = originalColors[i];
                
                if (disintegrationFactor < 0.5) {
                    // Original colors to metal gray transition (0-0.5)
                    const t = Math.max(0, (disintegrationFactor - 0.3) / 0.2);
                    
                    colors[i3] = origColor.r * (1 - t) + colorPalette.metalGray.r * t;
                    colors[i3 + 1] = origColor.g * (1 - t) + colorPalette.metalGray.g * t;
                    colors[i3 + 2] = origColor.b * (1 - t) + colorPalette.metalGray.b * t;
                } else {
                    // Metal gray to black transition (0.5-1.0)
                    const t = (disintegrationFactor - 0.5) / 0.5;
                    
                    colors[i3] = colorPalette.metalGray.r * (1 - t) + colorPalette.black.r * t;
                    colors[i3 + 1] = colorPalette.metalGray.g * (1 - t) + colorPalette.black.g * t;
                    colors[i3 + 2] = colorPalette.metalGray.b * (1 - t) + colorPalette.black.b * t;
                }
            }
            
            // Mark attributes as needing update
            pointCloud.geometry.attributes.position.needsUpdate = true;
            pointCloud.geometry.attributes.color.needsUpdate = true;
            
            // Update rotation speed based on disintegration factor
            rotationSpeed = 0.001 + (1 - disintegrationFactor) * 0.002;
        }
        
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Subtle rotation of the point cloud
            if (pointCloud && disintegrationFactor < 0.1) {
                pointCloud.rotation.y += rotationSpeed;
            }
            
            // Subtle camera movement based on mouse position
            camera.position.x += (mouseX * 0.05 - camera.position.x) * 0.01;
            camera.position.y += (-mouseY * 0.05 - camera.position.y) * 0.01;
            camera.lookAt(scene.position);
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>