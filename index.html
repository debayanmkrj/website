<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debayan Mukherjee | Creative Technologist</title>
    <style>
        :root {
            --metal-grey: #303030;
            --light-grey: #e0e0e0;
            --accent-red: #ff3333;
            --silver: #c0c0c0;
            --black: #000000;
            --white: #ffffff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }
        
        body {
            background-color: black;
            color: white;
            overflow: hidden;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: -1;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 2rem;
            z-index: 10;
            display: flex;
            justify-content: flex-end;
            align-items: center;
        }
        
        .home-icon {
            font-size: 1.5rem;
            color: var(--white);
            text-decoration: none;
            margin-right: 1rem;
            transition: color 0.3s ease;
        }
        
        .home-icon:hover {
            color: var(--accent-red);
        }
        
        .nav-links {
            display: flex;
            gap: 1.5rem;
        }
        
        .nav-link {
            color: var(--white);
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: color 0.3s ease;
        }
        
        .nav-link:hover {
            color: var(--accent-red);
        }
        
        /* Landing Content */
        .landing-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            width: 80%;
            max-width: 900px;
        }
        
        .name-title {
            font-size: 5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            text-shadow: 0 0 10px rgba(0,0,0,0.7), 0 0 20px rgba(0,0,0,0.5);
            letter-spacing: 2px;
        }
        
        .red-text {
            color: var(--accent-red);
            text-shadow: 0 0 10px rgba(255,51,51,0.3), 0 0 20px rgba(255,51,51,0.2);
        }
        
        .profession {
            font-size: 1.5rem;
            font-weight: 300;
            margin-bottom: 2rem;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            color: var(--light-grey);
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        
        .tagline {
            font-size: 1.8rem;
            font-weight: 300;
            font-style: italic;
            margin-bottom: 2rem;
            color: var(--light-grey);
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        
        /* Audio controls */
        #audio-controls {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .audio-btn {
            background-color: rgba(48, 48, 48, 0.7);
            color: var(--white);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        
        .audio-btn:hover {
            background-color: var(--accent-red);
        }
        
        /* Responsive styles */
        @media (max-width: 1024px) {
            .name-title {
                font-size: 4rem;
            }
        }
        
        @media (max-width: 768px) {
            .name-title {
                font-size: 3rem;
            }
            
            .profession {
                font-size: 1.2rem;
            }
            
            header {
                flex-direction: column;
                align-items: flex-end;
            }
            
            .nav-links {
                margin-top: 1rem;
                flex-wrap: wrap;
                justify-content: flex-end;
            }
        }
        
        @media (max-width: 480px) {
            .name-title {
                font-size: 2.5rem;
            }
            
            .tagline {
                font-size: 1.2rem;
            }
            
            .nav-links {
                gap: 1rem;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    
    <header>
        <div class="nav-links">
            <a href="pages/creative-design.html" class="nav-link">Creative Design</a>
            <a href="pages/visual-experience.html" class="nav-link">Visual Experience</a>
            <a href="pages/creative-tech.html" class="nav-link">Technology</a>
            <a href="pages/photography.html" class="nav-link">Photography</a>
            <a href="pages/about.html" class="nav-link">About</a>
        </div>
    </header>
    
    <div class="landing-content">
        <h1 class="name-title">Debayan <span class="red-text">Mukherjee</span></h1>
        <p class="tagline">Space to be updated based on next professional journey</p>
    </div>
    
    <div id="audio-controls">
        <button id="toggle-audio" class="audio-btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
            </svg>
        </button>
    </div>
    
    <audio id="background-audio" preload="auto" loop muted autoplay>
        <source src="./audio/landing_page.mp3" type="audio/mp3">
        Your browser does not support the audio element.
    </audio>
    
    <script>
        // Add a console message to confirm the script is running
        console.log("3D particle system initializing...");
        
        // This simple workaround should bypass autoplay restrictions
        window.onload = function() {
            // Wait a very short time before playing audio
            setTimeout(function() {
                // Create a user interaction event programmatically
                document.body.click();
                
                // Get the audio element and try to play
                var audio = document.getElementById('background-audio');
                
                // Unmute the audio (muted autoplay is allowed by browsers)
                audio.muted = false;
                
                // Play the audio
                var playPromise = audio.play();
                
                // Handle any potential issues
                if (playPromise !== undefined) {
                    playPromise.catch(function(error) {
                        // Auto-play was prevented
                        console.log("Audio couldn't play automatically. Please interact with the page to enable audio.");
                    });
                }
            }, 100);
        };
        
        // Three.js setup
        let scene, camera, renderer, pointCloud;
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;
        let disintegrationFactor = 0;
        let rotationSpeed = 0.001;
        
        // Audio variables
        let audioElement;
        let audioPlaying = false;
        
        // Higher particle count for better detail
        const pointCount = 250000;
        
        // Arrays to store original and target positions for disintegration
        let originalPositions = [];
        let targetPositions = [];
        let originalColors = [];  // Store original colors
        
        // Define our color palette
        const colorPalette = {
            red: { r: 1.0, g: 0.2, b: 0.2 },        // Accent red
            metalGray: { r: 0.19, g: 0.19, b: 0.19 }, // Metal gray #303030
            white: { r: 0.88, g: 0.88, b: 0.88 },   // White/light gray
            black: { r: 0.05, g: 0.05, b: 0.05 }    // Black
        };
        
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 600;
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true 
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Create a particle texture
            const particleTexture = createParticleTexture();
            
            // Create fashion tech point cloud directly
            createFashionTechPointCloud(particleTexture);
            
            // Add event listeners
            document.addEventListener('mousemove', onDocumentMouseMove);
            window.addEventListener('resize', onWindowResize);
            
            // Initialize audio
            initAudio();
            
            // Start animation loop
            animate();
        }
        
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            
            const context = canvas.getContext('2d');
            
            // Create radial gradient for soft-edged particle
            const gradient = context.createRadialGradient(
                16, 16, 0,    // inner circle
                16, 16, 16    // outer circle
            );
            
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');      // Center: full white
            gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');  // Mid: 80% white
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');      // Edge: transparent
            
            context.fillStyle = gradient;
            context.beginPath();
            context.arc(16, 16, 16, 0, Math.PI * 2);
            context.fill();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }
        
        function createFashionTechPointCloud(texture) {
            // Create a point cloud representing fashion tech
            console.log("Creating fashion tech point cloud");
            
            // Create geometry
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(pointCount * 3);
            const colors = new Float32Array(pointCount * 3);
            const sizes = new Float32Array(pointCount);
            
            // Use our color palette for fashion tech
            const fashionColors = [
                colorPalette.red,         // Red
                colorPalette.white,       // White
                colorPalette.metalGray,   // Metal gray
                colorPalette.black        // Black
            ];
            
            let index = 0;
            
            // Function to create a cluster of particles
            function createCluster(centerX, centerY, centerZ, width, height, depth, count, color, startIndex) {
                for (let i = 0; i < count && startIndex + i < pointCount; i++) {
                    const i3 = (startIndex + i) * 3;
                    
                    // Random position within the defined area
                    const x = centerX + (Math.random() - 0.5) * width;
                    const y = centerY + (Math.random() - 0.5) * height;
                    const z = centerZ + (Math.random() - 0.5) * depth;
                    
                    // Set position
                    positions[i3] = x;
                    positions[i3 + 1] = y;
                    positions[i3 + 2] = z;
                    
                    // Store original position
                    originalPositions.push({ x, y, z });
                    
                    // Create target position for disintegration
                    const distance = 800 + Math.random() * 1000;
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.random() * Math.PI;
                    
                    targetPositions.push({
                        x: distance * Math.sin(theta) * Math.cos(phi),
                        y: distance * Math.sin(theta) * Math.sin(phi),
                        z: distance * Math.cos(theta)
                    });
                    
                    // Set color
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                    
                    // Store original color
                    originalColors.push({
                        r: color.r,
                        g: color.g,
                        b: color.b
                    });
                    
                    // Set size
                    sizes[startIndex + i] = 2 + Math.random() * 3;
                }
                
                return startIndex + count;
            }
            
            // Create fashion elements with our color palette
            
            // Create a dress/fashion silhouette (use red for main form)
            index = createCluster(0, 0, 0, 150, 350, 50, 20000, fashionColors[0], index);
            
            // Create a flowing fabric effect (use white)
            index = createCluster(-100, -150, 30, 300, 100, 80, 15000, fashionColors[1], index);
            
            // Create tech elements (use metal gray)
            
            // Circuit board pattern
            for (let x = -200; x <= 200; x += 20) {
                for (let y = -200; y <= 200; y += 20) {
                    if (index < pointCount - 100) {
                        // Create a small cluster at each grid point
                        index = createCluster(x, y, 50, 5, 5, 5, 100, fashionColors[2], index);
                    }
                }
            }
            
            // Creative elements
            
            // Create a spiral pattern for creativity (use mix of colors)
            const spiralPoints = 20000;
            
            for (let i = 0; i < spiralPoints && index < pointCount; i++) {
                const i3 = index * 3;
                
                const angle = 0.1 * i;
                const radius = 2 * angle;
                
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                const z = angle * 0.5;
                
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
                
                originalPositions.push({ x, y, z });
                
                // Create target position for disintegration
                const distance = 800 + Math.random() * 1000;
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                
                targetPositions.push({
                    x: distance * Math.sin(theta) * Math.cos(phi),
                    y: distance * Math.sin(theta) * Math.sin(phi),
                    z: distance * Math.cos(theta)
                });
                
                // Choose a color based on position in spiral
                const colorIndex = Math.floor(i / 1000) % fashionColors.length;
                const spiralColor = fashionColors[colorIndex];
                
                colors[i3] = spiralColor.r;
                colors[i3 + 1] = spiralColor.g;
                colors[i3 + 2] = spiralColor.b;
                
                // Store original color
                originalColors.push({
                    r: spiralColor.r,
                    g: spiralColor.g,
                    b: spiralColor.b
                });
                
                sizes[index] = 1.5 + Math.random() * 2;
                
                index++;
            }
            
            // Fill remaining with scattered particles
            while (index < pointCount) {
                const i3 = index * 3;
                
                // Random position
                const distance = 100 + Math.random() * 300;
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                
                const x = distance * Math.sin(theta) * Math.cos(phi);
                const y = distance * Math.sin(theta) * Math.sin(phi);
                const z = distance * Math.cos(phi);
                
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
                
                originalPositions.push({ x, y, z });
                
                // Target position for disintegration
                const targetDistance = 1200 + Math.random() * 1000;
                const targetPhi = Math.random() * Math.PI * 2;
                const targetTheta = Math.random() * Math.PI;
                
                targetPositions.push({
                    x: targetDistance * Math.sin(targetTheta) * Math.cos(targetPhi),
                    y: targetDistance * Math.sin(targetTheta) * Math.sin(targetPhi),
                    z: targetDistance * Math.cos(targetPhi)
                });
                
                // Random color from our palette
                const color = fashionColors[Math.floor(Math.random() * fashionColors.length)];
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
                
                // Store original color
                originalColors.push({
                    r: color.r,
                    g: color.g,
                    b: color.b
                });
                
                // Small size
                sizes[index] = 1 + Math.random();
                
                index++;
            }
            
            // Create attributes
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Create material
            const material = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                map: texture,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            // Create point cloud
            pointCloud = new THREE.Points(geometry, material);
            
            // Add to scene
            scene.add(pointCloud);
        }
        
        function initAudio() {
            // Get audio element
            audioElement = document.getElementById('background-audio');
            audioPlaying = true;
            
            // Set up audio toggle button
            const toggleAudioBtn = document.getElementById('toggle-audio');
            toggleAudioBtn.addEventListener('click', toggleAudio);
            updateAudioButtonIcon();
        }
        
        function toggleAudio() {
            if (audioElement) {
                if (audioPlaying) {
                    audioElement.pause();
                    audioPlaying = false;
                } else {
                    audioElement.play();
                    audioPlaying = true;
                }
                
                updateAudioButtonIcon();
            }
        }
        
        function updateAudioButtonIcon() {
            const toggleAudioBtn = document.getElementById('toggle-audio');
            if (audioPlaying) {
                toggleAudioBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                        <line x1="23" y1="9" x2="17" y2="15"></line>
                        <line x1="17" y1="9" x2="23" y2="15"></line>
                    </svg>
                `;
            } else {
                toggleAudioBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                        <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                        <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                    </svg>
                `;
            }
        }
        
        function onDocumentMouseMove(event) {
            // Calculate mouse position normalized across the whole screen width
            const normalizedX = event.clientX / window.innerWidth;
            
            // Set disintegration factor directly from mouse position
            disintegrationFactor = normalizedX;
            
            // Store mouse position for camera effects
            mouseX = (event.clientX - windowHalfX);
            mouseY = (event.clientY - windowHalfY);
            
            // Update particles
            updateParticles();
            
            // Update audio volume based on mouse position
            if (audioElement && audioPlaying) {
                // When particles are more disintegrated (right side), volume is lower
                // When particles are more cohesive (left side), volume is higher
                audioElement.volume = 1.0 - (normalizedX * 0.7); // Volume range from 1.0 to 0.3
            }
        }
        
        function updateParticles() {
            if (!pointCloud) return;
            
            const positions = pointCloud.geometry.attributes.position.array;
            const colors = pointCloud.geometry.attributes.color.array;
            
            // Update each particle
            for (let i = 0; i < originalPositions.length; i++) {
                const i3 = i * 3;
                
                // Update position based on disintegration factor
                const orig = originalPositions[i];
                const target = targetPositions[i];
                
                positions[i3] = orig.x * (1 - disintegrationFactor) + target.x * disintegrationFactor;
                positions[i3 + 1] = orig.y * (1 - disintegrationFactor) + target.y * disintegrationFactor;
                positions[i3 + 2] = orig.z * (1 - disintegrationFactor) + target.z * disintegrationFactor;
                
                // FIXED COLOR TRANSITION LOGIC
                // This is the key change to maintain the color palette during transition
                const origColor = originalColors[i];
                
                if (disintegrationFactor < 0.5) {
                    // Original colors to metal gray transition (0-0.5)
                    // For the first half of the mouse movement, keep original colors
                    // Only slowly start to introduce metal gray as we approach 0.5
                    const t = Math.max(0, (disintegrationFactor - 0.3) / 0.2);
                    
                    // Maintain the original color but slightly transition toward metal gray
                    colors[i3] = origColor.r * (1 - t) + colorPalette.metalGray.r * t;
                    colors[i3 + 1] = origColor.g * (1 - t) + colorPalette.metalGray.g * t;
                    colors[i3 + 2] = origColor.b * (1 - t) + colorPalette.metalGray.b * t;
                } else {
                    // Metal gray to black transition (0.5-1.0)
                    const t = (disintegrationFactor - 0.5) / 0.5;
                    
                    // Transition from metal gray to black
                    colors[i3] = colorPalette.metalGray.r * (1 - t) + colorPalette.black.r * t;
                    colors[i3 + 1] = colorPalette.metalGray.g * (1 - t) + colorPalette.black.g * t;
                    colors[i3 + 2] = colorPalette.metalGray.b * (1 - t) + colorPalette.black.b * t;
                }
            }
            
            // Mark attributes as needing update
            pointCloud.geometry.attributes.position.needsUpdate = true;
            pointCloud.geometry.attributes.color.needsUpdate = true;
            
            // Update rotation speed based on disintegration factor
            rotationSpeed = 0.001 + (1 - disintegrationFactor) * 0.002;
        }
        
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Subtle rotation of the point cloud
            if (pointCloud && disintegrationFactor < 0.1) {
                pointCloud.rotation.y += rotationSpeed;
            }
            
            // Subtle camera movement based on mouse position
            camera.position.x += (mouseX * 0.05 - camera.position.x) * 0.01;
            camera.position.y += (-mouseY * 0.05 - camera.position.y) * 0.01;
            camera.lookAt(scene.position);
            
            renderer.render(scene, camera);
        }
        
        // Initialize the 3D scene
        init();
    </script>
</body>
</html>