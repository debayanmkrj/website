<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>debsweb | Creative Technologist</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --metal-grey: #303030;
            --light-grey: #e0e0e0;
            --accent-red: #ff3333;
            --silver: #c0c0c0;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }
        
        body {
            background-color: black;
            color: white;
            overflow: hidden;
        }
        
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 2rem;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            font-size: 2rem;
            font-weight: 700;
            color: white;
            text-decoration: none;
            text-transform: lowercase;
        }
        
        .logo span {
            color: var(--accent-red);
        }
        
        .contact {
            position: absolute;
            bottom: 2rem;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
        }
        
        .contact p {
            font-size: 1rem;
            color: var(--light-grey);
        }
        
        #download-btn {
            position: absolute;
            bottom: 4rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background-color: var(--accent-red);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            z-index: 10;
        }
        
        #download-btn:hover {
            background-color: #ff5555;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    
    <header>
        <a href="#" class="logo">debs<span>web</span></a>
    </header>
    
    <div class="contact">
        <p>Reach out to Debayan</p>
    </div>
    
    <button id="download-btn">Download Code</button>
    
    <script>
        // Three.js setup
        let scene, camera, renderer, pointCloud;
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;
        let disintegrationFactor = 0;
        let rotationSpeed = 0.001;
        // Higher particle count for better detail
        const pointCount = 250000;
        
        // Arrays to store original and target positions for disintegration
        let originalPositions = [];
        let targetPositions = [];
        let originalColors = [];  // Store original colors
        
        // Define our color palette
        const colorPalette = {
            red: { r: 1.0, g: 0.2, b: 0.2 },        // Accent red
            metalGray: { r: 0.19, g: 0.19, b: 0.19 }, // Metal gray #303030
            white: { r: 0.88, g: 0.88, b: 0.88 },   // White/light gray
            black: { r: 0.05, g: 0.05, b: 0.05 }    // Black
        };
        
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 600;
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true 
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Create a particle texture
            const particleTexture = createParticleTexture();
            
            // Try to load the portrait image
            loadPortraitImage(particleTexture);
            
            // Add event listeners
            document.addEventListener('mousemove', onDocumentMouseMove);
            window.addEventListener('resize', onWindowResize);
            
            // Add download functionality
            document.getElementById('download-btn').addEventListener('click', downloadCode);
            
            // Start animation loop
            animate();
        }
        
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            
            const context = canvas.getContext('2d');
            
            // Create radial gradient for soft-edged particle
            const gradient = context.createRadialGradient(
                16, 16, 0,    // inner circle
                16, 16, 16    // outer circle
            );
            
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');      // Center: full white
            gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');  // Mid: 80% white
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');      // Edge: transparent
            
            context.fillStyle = gradient;
            context.beginPath();
            context.arc(16, 16, 16, 0, Math.PI * 2);
            context.fill();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }
        
        function loadPortraitImage(texture) {
            const img = new Image();
            
            img.onload = function() {
                createParticlesFromImage(img, texture);
            };
            
            img.onerror = function() {
                console.error("Failed to load image. Creating fashion tech point cloud...");
                createFashionTechPointCloud(texture);
            };
            
            // Set the local path to the image
            img.src = "C:\\Users\\dbmkr\\Downloads\\website_potrait.png";
            
            // Set a timeout in case the image takes too long to load
            setTimeout(() => {
                if (!pointCloud) {
                    console.log("Image load timeout. Creating fashion tech point cloud...");
                    createFashionTechPointCloud(texture);
                }
            }, 3000);
        }
        
        function createParticlesFromImage(image, texture) {
            // Create a canvas to analyze the image
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // Set canvas dimensions to match image
            canvas.width = image.width;
            canvas.height = image.height;
            
            // Draw image onto canvas for pixel manipulation
            context.drawImage(image, 0, 0);
            
            // Get image data
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Create arrays for the particle system
            const positions = new Float32Array(pointCount * 3);
            const colors = new Float32Array(pointCount * 3);
            const sizes = new Float32Array(pointCount);
            
            // Collect points with varying density based on image features
            const potentialPoints = [];
            
            // Sample the image
            const samplingStep = 1; // Adjust for more or fewer points
            
            for (let y = 0; y < canvas.height; y += samplingStep) {
                for (let x = 0; x < canvas.width; x += samplingStep) {
                    const i = (y * canvas.width + x) * 4;
                    
                    // Get RGBA values
                    const r = data[i] / 255;
                    const g = data[i + 1] / 255;
                    const b = data[i + 2] / 255;
                    const a = data[i + 3] / 255;
                    
                    // Skip transparent or very light/white pixels (background)
                    if (a < 0.5 || (r > 0.95 && g > 0.95 && b > 0.95)) {
                        continue;
                    }
                    
                    // Calculate brightness
                    const brightness = (r + g + b) / 3;
                    
                    // Determine sampling probability based on features
                    let probability = 0.1; // Base probability
                    
                    // Increase probability for skin tones
                    if (r > 0.5 && g > 0.3 && b > 0.2 && r > g && g > b) {
                        probability = 0.6;
                    }
                    
                    // Increase probability for hair
                    if (brightness < 0.3) {
                        probability = 0.7;
                    }
                    
                    // Increase probability for the brown flower
                    if (r > 0.4 && r < 0.7 && g > 0.2 && g < 0.4 && b > 0.1 && b < 0.3) {
                        probability = 0.8;
                    }
                    
                    // Increase probability for lips
                    if (r > 0.6 && g > 0.3 && g < 0.5 && b > 0.3 && b < 0.5) {
                        probability = 0.7;
                    }
                    
                    // Increase probability for eyes
                    if (brightness < 0.3 && x > canvas.width * 0.3 && x < canvas.width * 0.7 && y > canvas.height * 0.3 && y < canvas.height * 0.5) {
                        probability = 0.9;
                    }
                    
                    if (Math.random() < probability) {
                        potentialPoints.push({
                            x: x,
                            y: y,
                            r: r,
                            g: g,
                            b: b,
                            brightness: brightness
                        });
                    }
                }
            }
            
            // Shuffle points and select subset if we have too many
            const shuffledPoints = potentialPoints.sort(() => 0.5 - Math.random());
            const selectedPoints = shuffledPoints.slice(0, pointCount);
            
            // Create particles from the selected points
            for (let i = 0; i < selectedPoints.length && i < pointCount; i++) {
                const point = selectedPoints[i];
                const i3 = i * 3;
                
                // Calculate normalized position (-0.5 to 0.5)
                const normalizedX = (point.x / canvas.width - 0.5);
                const normalizedY = -(point.y / canvas.height - 0.5); // Flip Y axis
                
                // Scale to scene size
                const xPos = normalizedX * 800;
                const yPos = normalizedY * 800;
                
                // Use brightness for z-position to create depth
                // Darker pixels are pushed forward
                const zPos = (1 - point.brightness) * 150;
                
                // Set position
                positions[i3] = xPos;
                positions[i3 + 1] = yPos;
                positions[i3 + 2] = zPos;
                
                // Store original position for animation
                originalPositions.push({
                    x: xPos,
                    y: yPos,
                    z: zPos
                });
                
                // Create target position for disintegration
                const distance = 800 + Math.random() * 1000;
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                
                targetPositions.push({
                    x: distance * Math.sin(theta) * Math.cos(phi),
                    y: distance * Math.sin(theta) * Math.sin(phi),
                    z: distance * Math.cos(theta)
                });
                
                // Map the colors to our palette
                let mappedColor;
                const brightness = point.brightness;
                
                // Choose color based on brightness and RGB values
                if (point.r > 0.5 && point.r > point.g * 1.2 && point.r > point.b * 1.2) {
                    // Reddish tones from the image become accent red
                    mappedColor = colorPalette.red;
                } else if (brightness < 0.3) {
                    // Dark areas become metal gray
                    mappedColor = colorPalette.metalGray;
                } else if (brightness > 0.7) {
                    // Bright areas become white
                    mappedColor = colorPalette.white;
                } else {
                    // Medium brightness becomes a gradient between metal gray and white
                    const t = (brightness - 0.3) / 0.4; // Normalize between 0.3-0.7
                    mappedColor = {
                        r: colorPalette.metalGray.r * (1 - t) + colorPalette.white.r * t,
                        g: colorPalette.metalGray.g * (1 - t) + colorPalette.white.g * t,
                        b: colorPalette.metalGray.b * (1 - t) + colorPalette.white.b * t
                    };
                }
                
                // Set color based on original image pixel mapped to our palette
                colors[i3] = mappedColor.r;
                colors[i3 + 1] = mappedColor.g;
                colors[i3 + 2] = mappedColor.b;
                
                // Store original color for animation
                originalColors.push({
                    r: mappedColor.r,
                    g: mappedColor.g,
                    b: mappedColor.b
                });
                
                // Vary particle size based on brightness
                // Darker pixels get slightly larger particles
                sizes[i] = 2.0 + (1.0 - point.brightness) * 3.0;
            }
            
            // Fill remaining particles if needed
            for (let i = selectedPoints.length; i < pointCount; i++) {
                const i3 = i * 3;
                
                // Random position in 3D space, but keep it within frame boundary
                const xPos = (Math.random() - 0.5) * 1000;
                const yPos = (Math.random() - 0.5) * 1000;
                const zPos = Math.random() * 500 - 600; // Behind the portrait
                
                positions[i3] = xPos;
                positions[i3 + 1] = yPos;
                positions[i3 + 2] = zPos;
                
                originalPositions.push({
                    x: xPos,
                    y: yPos,
                    z: zPos
                });
                
                // Target position for disintegration
                const distance = 1200 + Math.random() * 1000;
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                
                targetPositions.push({
                    x: distance * Math.sin(theta) * Math.cos(phi),
                    y: distance * Math.sin(theta) * Math.sin(phi),
                    z: distance * Math.cos(theta)
                });
                
                // Dark background color - metal gray or black
                const useMetalGray = Math.random() > 0.5;
                const mappedColor = useMetalGray ? colorPalette.metalGray : colorPalette.black;
                
                // Store original color
                originalColors.push({
                    r: mappedColor.r,
                    g: mappedColor.g,
                    b: mappedColor.b
                });
                
                // Set color
                colors[i3] = mappedColor.r;
                colors[i3 + 1] = mappedColor.g;
                colors[i3 + 2] = mappedColor.b;
                
                // Smaller size for background particles
                sizes[i] = 0.8 + Math.random() * 1.2;
            }
            
            // Create geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Create material with our custom texture
            const material = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                map: texture,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            // Create point cloud
            pointCloud = new THREE.Points(geometry, material);
            
            // Add to scene
            scene.add(pointCloud);
        }
        
        function createFashionTechPointCloud(texture) {
            // Create a point cloud representing fashion tech
            console.log("Creating fashion tech point cloud");
            
            // Create geometry
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(pointCount * 3);
            const colors = new Float32Array(pointCount * 3);
            const sizes = new Float32Array(pointCount);
            
            // Use our color palette for fashion tech
            const fashionColors = [
                colorPalette.red,         // Red
                colorPalette.white,       // White
                colorPalette.metalGray,   // Metal gray
                colorPalette.black        // Black
            ];
            
            let index = 0;
            
            // Function to create a cluster of particles
            function createCluster(centerX, centerY, centerZ, width, height, depth, count, color, startIndex) {
                for (let i = 0; i < count && startIndex + i < pointCount; i++) {
                    const i3 = (startIndex + i) * 3;
                    
                    // Random position within the defined area
                    const x = centerX + (Math.random() - 0.5) * width;
                    const y = centerY + (Math.random() - 0.5) * height;
                    const z = centerZ + (Math.random() - 0.5) * depth;
                    
                    // Set position
                    positions[i3] = x;
                    positions[i3 + 1] = y;
                    positions[i3 + 2] = z;
                    
                    // Store original position
                    originalPositions.push({ x, y, z });
                    
                    // Create target position for disintegration
                    const distance = 800 + Math.random() * 1000;
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.random() * Math.PI;
                    
                    targetPositions.push({
                        x: distance * Math.sin(theta) * Math.cos(phi),
                        y: distance * Math.sin(theta) * Math.sin(phi),
                        z: distance * Math.cos(theta)
                    });
                    
                    // Set color
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                    
                    // Store original color
                    originalColors.push({
                        r: color.r,
                        g: color.g,
                        b: color.b
                    });
                    
                    // Set size
                    sizes[startIndex + i] = 2 + Math.random() * 3;
                }
                
                return startIndex + count;
            }
            
            // Create fashion elements with our color palette
            
            // Create a dress/fashion silhouette (use red for main form)
            index = createCluster(0, 0, 0, 150, 350, 50, 20000, fashionColors[0], index);
            
            // Create a flowing fabric effect (use white)
            index = createCluster(-100, -150, 30, 300, 100, 80, 15000, fashionColors[1], index);
            
            // Create tech elements (use metal gray)
            
            // Circuit board pattern
            for (let x = -200; x <= 200; x += 20) {
                for (let y = -200; y <= 200; y += 20) {
                    if (index < pointCount - 100) {
                        // Create a small cluster at each grid point
                        index = createCluster(x, y, 50, 5, 5, 5, 100, fashionColors[2], index);
                    }
                }
            }
            
            // Creative elements
            
            // Create a spiral pattern for creativity (use mix of colors)
            const spiralPoints = 20000;
            
            for (let i = 0; i < spiralPoints && index < pointCount; i++) {
                const i3 = index * 3;
                
                const angle = 0.1 * i;
                const radius = 2 * angle;
                
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                const z = angle * 0.5;
                
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
                
                originalPositions.push({ x, y, z });
                
                // Create target position for disintegration
                const distance = 800 + Math.random() * 1000;
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                
                targetPositions.push({
                    x: distance * Math.sin(theta) * Math.cos(phi),
                    y: distance * Math.sin(theta) * Math.sin(phi),
                    z: distance * Math.cos(theta)
                });
                
                // Choose a color based on position in spiral
                const colorIndex = Math.floor(i / 1000) % fashionColors.length;
                const spiralColor = fashionColors[colorIndex];
                
                colors[i3] = spiralColor.r;
                colors[i3 + 1] = spiralColor.g;
                colors[i3 + 2] = spiralColor.b;
                
                // Store original color
                originalColors.push({
                    r: spiralColor.r,
                    g: spiralColor.g,
                    b: spiralColor.b
                });
                
                sizes[index] = 1.5 + Math.random() * 2;
                
                index++;
            }
            
            // Fill remaining with scattered particles
            while (index < pointCount) {
                const i3 = index * 3;
                
                // Random position
                const distance = 100 + Math.random() * 300;
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                
                const x = distance * Math.sin(theta) * Math.cos(phi);
                const y = distance * Math.sin(theta) * Math.sin(phi);
                const z = distance * Math.cos(phi);
                
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
                
                originalPositions.push({ x, y, z });
                
                // Target position for disintegration
                const targetDistance = 1200 + Math.random() * 1000;
                const targetPhi = Math.random() * Math.PI * 2;
                const targetTheta = Math.random() * Math.PI;
                
                targetPositions.push({
                    x: targetDistance * Math.sin(targetTheta) * Math.cos(targetPhi),
                    y: targetDistance * Math.sin(targetTheta) * Math.sin(targetPhi),
                    z: targetDistance * Math.cos(targetPhi)
                });
                
                // Random color from our palette
                const color = fashionColors[Math.floor(Math.random() * fashionColors.length)];
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
                
                // Store original color
                originalColors.push({
                    r: color.r,
                    g: color.g,
                    b: color.b
                });
                
                // Small size
                sizes[index] = 1 + Math.random();
                
                index++;
            }
            
            // Create attributes
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Create material
            const material = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                map: texture,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            // Create point cloud
            pointCloud = new THREE.Points(geometry, material);
            
            // Add to scene
            scene.add(pointCloud);
        }
        
        function onDocumentMouseMove(event) {
            // Calculate mouse position normalized across the whole screen width
            const normalizedX = event.clientX / window.innerWidth;
            
            // Set disintegration factor directly from mouse position
            disintegrationFactor = normalizedX;
            
            // Store mouse position for camera effects
            mouseX = (event.clientX - windowHalfX);
            mouseY = (event.clientY - windowHalfY);
            
            // Update particles
            updateParticles();
        }
        
        function updateParticles() {
            if (!pointCloud) return;
            
            const positions = pointCloud.geometry.attributes.position.array;
            const colors = pointCloud.geometry.attributes.color.array;
            
            // Update each particle
            for (let i = 0; i < originalPositions.length; i++) {
                const i3 = i * 3;
                
                // Update position based on disintegration factor
                const orig = originalPositions[i];
                const target = targetPositions[i];
                
                positions[i3] = orig.x * (1 - disintegrationFactor) + target.x * disintegrationFactor;
                positions[i3 + 1] = orig.y * (1 - disintegrationFactor) + target.y * disintegrationFactor;
                positions[i3 + 2] = orig.z * (1 - disintegrationFactor) + target.z * disintegrationFactor;
                
                // FIXED COLOR TRANSITION LOGIC
                // This is the key change to maintain the color palette during transition
                const origColor = originalColors[i];
                
                if (disintegrationFactor < 0.5) {
                    // Original colors to metal gray transition (0-0.5)
                    // For the first half of the mouse movement, keep original colors
                    // Only slowly start to introduce metal gray as we approach 0.5
                    const t = Math.max(0, (disintegrationFactor - 0.3) / 0.2);
                    
                    // Maintain the original color but slightly transition toward metal gray
                    colors[i3] = origColor.r * (1 - t) + colorPalette.metalGray.r * t;
                    colors[i3 + 1] = origColor.g * (1 - t) + colorPalette.metalGray.g * t;
                    colors[i3 + 2] = origColor.b * (1 - t) + colorPalette.metalGray.b * t;
                } else {
                    // Metal gray to black transition (0.5-1.0)
                    const t = (disintegrationFactor - 0.5) / 0.5;
                    
                    // Transition from metal gray to black
                    colors[i3] = colorPalette.metalGray.r * (1 - t) + colorPalette.black.r * t;
                    colors[i3 + 1] = colorPalette.metalGray.g * (1 - t) + colorPalette.black.g * t;
                    colors[i3 + 2] = colorPalette.metalGray.b * (1 - t) + colorPalette.black.b * t;
                }
            }
            
            // Mark attributes as needing update
            pointCloud.geometry.attributes.position.needsUpdate = true;
            pointCloud.geometry.attributes.color.needsUpdate = true;
        }
        
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Subtle rotation of the point cloud
            if (pointCloud && disintegrationFactor < 0.1) {
                pointCloud.rotation.y += rotationSpeed;
            }
            
            // Subtle camera movement based on mouse position
            camera.position.x += (mouseX * 0.05 - camera.position.x) * 0.01;
            camera.position.y += (-mouseY * 0.05 - camera.position.y) * 0.01;
            camera.lookAt(scene.position);
            
            renderer.render(scene, camera);
        }
        
        function downloadCode() {
            // Get the HTML content
            const htmlContent = document.documentElement.outerHTML;
            
            // Create a blob with the content
            const blob = new Blob([htmlContent], { type: 'text/html' });
            
            // Create a download link
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'debsweb-creative-tech.html';
            
            // Trigger the download
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }
        
        // Initialize the 3D scene
        init();
    </script>
</body>
</html>